// Code generated by counterfeiter. DO NOT EDIT.
package chaincodefakes

import (
	"market/chaincode"
	"sync"

	"github.com/hyperledger/fabric-chaincode-go/pkg/cid"
	"github.com/hyperledger/fabric-chaincode-go/shim"
)

type CustomContex struct {
	CheckProducerStub        func(string) (bool, error)
	checkProducerMutex       sync.RWMutex
	checkProducerArgsForCall []struct {
		arg1 string
	}
	checkProducerReturns struct {
		result1 bool
		result2 error
	}
	checkProducerReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	CreateOfferStub        func(string, int, int, string) error
	createOfferMutex       sync.RWMutex
	createOfferArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
		arg4 string
	}
	createOfferReturns struct {
		result1 error
	}
	createOfferReturnsOnCall map[int]struct {
		result1 error
	}
	GetClientIdentityStub        func() cid.ClientIdentity
	getClientIdentityMutex       sync.RWMutex
	getClientIdentityArgsForCall []struct {
	}
	getClientIdentityReturns struct {
		result1 cid.ClientIdentity
	}
	getClientIdentityReturnsOnCall map[int]struct {
		result1 cid.ClientIdentity
	}
	GetProducerStub        func(string) *chaincode.Producer
	getProducerMutex       sync.RWMutex
	getProducerArgsForCall []struct {
		arg1 string
	}
	getProducerReturns struct {
		result1 *chaincode.Producer
	}
	getProducerReturnsOnCall map[int]struct {
		result1 *chaincode.Producer
	}
	GetResultStub        func(string, interface{}) error
	getResultMutex       sync.RWMutex
	getResultArgsForCall []struct {
		arg1 string
		arg2 interface{}
	}
	getResultReturns struct {
		result1 error
	}
	getResultReturnsOnCall map[int]struct {
		result1 error
	}
	GetSellableStub        func(string) (int, error)
	getSellableMutex       sync.RWMutex
	getSellableArgsForCall []struct {
		arg1 string
	}
	getSellableReturns struct {
		result1 int
		result2 error
	}
	getSellableReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	GetStubStub        func() shim.ChaincodeStubInterface
	getStubMutex       sync.RWMutex
	getStubArgsForCall []struct {
	}
	getStubReturns struct {
		result1 shim.ChaincodeStubInterface
	}
	getStubReturnsOnCall map[int]struct {
		result1 shim.ChaincodeStubInterface
	}
	GetUserIdStub        func() (string, error)
	getUserIdMutex       sync.RWMutex
	getUserIdArgsForCall []struct {
	}
	getUserIdReturns struct {
		result1 string
		result2 error
	}
	getUserIdReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetUserTypeStub        func() (string, error)
	getUserTypeMutex       sync.RWMutex
	getUserTypeArgsForCall []struct {
	}
	getUserTypeReturns struct {
		result1 string
		result2 error
	}
	getUserTypeReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	IteratorResultsStub        func(shim.StateQueryIteratorInterface, interface{}) error
	iteratorResultsMutex       sync.RWMutex
	iteratorResultsArgsForCall []struct {
		arg1 shim.StateQueryIteratorInterface
		arg2 interface{}
	}
	iteratorResultsReturns struct {
		result1 error
	}
	iteratorResultsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *CustomContex) CheckProducer(arg1 string) (bool, error) {
	fake.checkProducerMutex.Lock()
	ret, specificReturn := fake.checkProducerReturnsOnCall[len(fake.checkProducerArgsForCall)]
	fake.checkProducerArgsForCall = append(fake.checkProducerArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CheckProducerStub
	fakeReturns := fake.checkProducerReturns
	fake.recordInvocation("CheckProducer", []interface{}{arg1})
	fake.checkProducerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *CustomContex) CheckProducerCallCount() int {
	fake.checkProducerMutex.RLock()
	defer fake.checkProducerMutex.RUnlock()
	return len(fake.checkProducerArgsForCall)
}

func (fake *CustomContex) CheckProducerCalls(stub func(string) (bool, error)) {
	fake.checkProducerMutex.Lock()
	defer fake.checkProducerMutex.Unlock()
	fake.CheckProducerStub = stub
}

func (fake *CustomContex) CheckProducerArgsForCall(i int) string {
	fake.checkProducerMutex.RLock()
	defer fake.checkProducerMutex.RUnlock()
	argsForCall := fake.checkProducerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *CustomContex) CheckProducerReturns(result1 bool, result2 error) {
	fake.checkProducerMutex.Lock()
	defer fake.checkProducerMutex.Unlock()
	fake.CheckProducerStub = nil
	fake.checkProducerReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *CustomContex) CheckProducerReturnsOnCall(i int, result1 bool, result2 error) {
	fake.checkProducerMutex.Lock()
	defer fake.checkProducerMutex.Unlock()
	fake.CheckProducerStub = nil
	if fake.checkProducerReturnsOnCall == nil {
		fake.checkProducerReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkProducerReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *CustomContex) CreateOffer(arg1 string, arg2 int, arg3 int, arg4 string) error {
	fake.createOfferMutex.Lock()
	ret, specificReturn := fake.createOfferReturnsOnCall[len(fake.createOfferArgsForCall)]
	fake.createOfferArgsForCall = append(fake.createOfferArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreateOfferStub
	fakeReturns := fake.createOfferReturns
	fake.recordInvocation("CreateOffer", []interface{}{arg1, arg2, arg3, arg4})
	fake.createOfferMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *CustomContex) CreateOfferCallCount() int {
	fake.createOfferMutex.RLock()
	defer fake.createOfferMutex.RUnlock()
	return len(fake.createOfferArgsForCall)
}

func (fake *CustomContex) CreateOfferCalls(stub func(string, int, int, string) error) {
	fake.createOfferMutex.Lock()
	defer fake.createOfferMutex.Unlock()
	fake.CreateOfferStub = stub
}

func (fake *CustomContex) CreateOfferArgsForCall(i int) (string, int, int, string) {
	fake.createOfferMutex.RLock()
	defer fake.createOfferMutex.RUnlock()
	argsForCall := fake.createOfferArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *CustomContex) CreateOfferReturns(result1 error) {
	fake.createOfferMutex.Lock()
	defer fake.createOfferMutex.Unlock()
	fake.CreateOfferStub = nil
	fake.createOfferReturns = struct {
		result1 error
	}{result1}
}

func (fake *CustomContex) CreateOfferReturnsOnCall(i int, result1 error) {
	fake.createOfferMutex.Lock()
	defer fake.createOfferMutex.Unlock()
	fake.CreateOfferStub = nil
	if fake.createOfferReturnsOnCall == nil {
		fake.createOfferReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createOfferReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *CustomContex) GetClientIdentity() cid.ClientIdentity {
	fake.getClientIdentityMutex.Lock()
	ret, specificReturn := fake.getClientIdentityReturnsOnCall[len(fake.getClientIdentityArgsForCall)]
	fake.getClientIdentityArgsForCall = append(fake.getClientIdentityArgsForCall, struct {
	}{})
	stub := fake.GetClientIdentityStub
	fakeReturns := fake.getClientIdentityReturns
	fake.recordInvocation("GetClientIdentity", []interface{}{})
	fake.getClientIdentityMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *CustomContex) GetClientIdentityCallCount() int {
	fake.getClientIdentityMutex.RLock()
	defer fake.getClientIdentityMutex.RUnlock()
	return len(fake.getClientIdentityArgsForCall)
}

func (fake *CustomContex) GetClientIdentityCalls(stub func() cid.ClientIdentity) {
	fake.getClientIdentityMutex.Lock()
	defer fake.getClientIdentityMutex.Unlock()
	fake.GetClientIdentityStub = stub
}

func (fake *CustomContex) GetClientIdentityReturns(result1 cid.ClientIdentity) {
	fake.getClientIdentityMutex.Lock()
	defer fake.getClientIdentityMutex.Unlock()
	fake.GetClientIdentityStub = nil
	fake.getClientIdentityReturns = struct {
		result1 cid.ClientIdentity
	}{result1}
}

func (fake *CustomContex) GetClientIdentityReturnsOnCall(i int, result1 cid.ClientIdentity) {
	fake.getClientIdentityMutex.Lock()
	defer fake.getClientIdentityMutex.Unlock()
	fake.GetClientIdentityStub = nil
	if fake.getClientIdentityReturnsOnCall == nil {
		fake.getClientIdentityReturnsOnCall = make(map[int]struct {
			result1 cid.ClientIdentity
		})
	}
	fake.getClientIdentityReturnsOnCall[i] = struct {
		result1 cid.ClientIdentity
	}{result1}
}

func (fake *CustomContex) GetProducer(arg1 string) *chaincode.Producer {
	fake.getProducerMutex.Lock()
	ret, specificReturn := fake.getProducerReturnsOnCall[len(fake.getProducerArgsForCall)]
	fake.getProducerArgsForCall = append(fake.getProducerArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetProducerStub
	fakeReturns := fake.getProducerReturns
	fake.recordInvocation("GetProducer", []interface{}{arg1})
	fake.getProducerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *CustomContex) GetProducerCallCount() int {
	fake.getProducerMutex.RLock()
	defer fake.getProducerMutex.RUnlock()
	return len(fake.getProducerArgsForCall)
}

func (fake *CustomContex) GetProducerCalls(stub func(string) *chaincode.Producer) {
	fake.getProducerMutex.Lock()
	defer fake.getProducerMutex.Unlock()
	fake.GetProducerStub = stub
}

func (fake *CustomContex) GetProducerArgsForCall(i int) string {
	fake.getProducerMutex.RLock()
	defer fake.getProducerMutex.RUnlock()
	argsForCall := fake.getProducerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *CustomContex) GetProducerReturns(result1 *chaincode.Producer) {
	fake.getProducerMutex.Lock()
	defer fake.getProducerMutex.Unlock()
	fake.GetProducerStub = nil
	fake.getProducerReturns = struct {
		result1 *chaincode.Producer
	}{result1}
}

func (fake *CustomContex) GetProducerReturnsOnCall(i int, result1 *chaincode.Producer) {
	fake.getProducerMutex.Lock()
	defer fake.getProducerMutex.Unlock()
	fake.GetProducerStub = nil
	if fake.getProducerReturnsOnCall == nil {
		fake.getProducerReturnsOnCall = make(map[int]struct {
			result1 *chaincode.Producer
		})
	}
	fake.getProducerReturnsOnCall[i] = struct {
		result1 *chaincode.Producer
	}{result1}
}

func (fake *CustomContex) GetResult(arg1 string, arg2 interface{}) error {
	fake.getResultMutex.Lock()
	ret, specificReturn := fake.getResultReturnsOnCall[len(fake.getResultArgsForCall)]
	fake.getResultArgsForCall = append(fake.getResultArgsForCall, struct {
		arg1 string
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.GetResultStub
	fakeReturns := fake.getResultReturns
	fake.recordInvocation("GetResult", []interface{}{arg1, arg2})
	fake.getResultMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *CustomContex) GetResultCallCount() int {
	fake.getResultMutex.RLock()
	defer fake.getResultMutex.RUnlock()
	return len(fake.getResultArgsForCall)
}

func (fake *CustomContex) GetResultCalls(stub func(string, interface{}) error) {
	fake.getResultMutex.Lock()
	defer fake.getResultMutex.Unlock()
	fake.GetResultStub = stub
}

func (fake *CustomContex) GetResultArgsForCall(i int) (string, interface{}) {
	fake.getResultMutex.RLock()
	defer fake.getResultMutex.RUnlock()
	argsForCall := fake.getResultArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *CustomContex) GetResultReturns(result1 error) {
	fake.getResultMutex.Lock()
	defer fake.getResultMutex.Unlock()
	fake.GetResultStub = nil
	fake.getResultReturns = struct {
		result1 error
	}{result1}
}

func (fake *CustomContex) GetResultReturnsOnCall(i int, result1 error) {
	fake.getResultMutex.Lock()
	defer fake.getResultMutex.Unlock()
	fake.GetResultStub = nil
	if fake.getResultReturnsOnCall == nil {
		fake.getResultReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getResultReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *CustomContex) GetSellable(arg1 string) (int, error) {
	fake.getSellableMutex.Lock()
	ret, specificReturn := fake.getSellableReturnsOnCall[len(fake.getSellableArgsForCall)]
	fake.getSellableArgsForCall = append(fake.getSellableArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetSellableStub
	fakeReturns := fake.getSellableReturns
	fake.recordInvocation("GetSellable", []interface{}{arg1})
	fake.getSellableMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *CustomContex) GetSellableCallCount() int {
	fake.getSellableMutex.RLock()
	defer fake.getSellableMutex.RUnlock()
	return len(fake.getSellableArgsForCall)
}

func (fake *CustomContex) GetSellableCalls(stub func(string) (int, error)) {
	fake.getSellableMutex.Lock()
	defer fake.getSellableMutex.Unlock()
	fake.GetSellableStub = stub
}

func (fake *CustomContex) GetSellableArgsForCall(i int) string {
	fake.getSellableMutex.RLock()
	defer fake.getSellableMutex.RUnlock()
	argsForCall := fake.getSellableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *CustomContex) GetSellableReturns(result1 int, result2 error) {
	fake.getSellableMutex.Lock()
	defer fake.getSellableMutex.Unlock()
	fake.GetSellableStub = nil
	fake.getSellableReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *CustomContex) GetSellableReturnsOnCall(i int, result1 int, result2 error) {
	fake.getSellableMutex.Lock()
	defer fake.getSellableMutex.Unlock()
	fake.GetSellableStub = nil
	if fake.getSellableReturnsOnCall == nil {
		fake.getSellableReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.getSellableReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *CustomContex) GetStub() shim.ChaincodeStubInterface {
	fake.getStubMutex.Lock()
	ret, specificReturn := fake.getStubReturnsOnCall[len(fake.getStubArgsForCall)]
	fake.getStubArgsForCall = append(fake.getStubArgsForCall, struct {
	}{})
	stub := fake.GetStubStub
	fakeReturns := fake.getStubReturns
	fake.recordInvocation("GetStub", []interface{}{})
	fake.getStubMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *CustomContex) GetStubCallCount() int {
	fake.getStubMutex.RLock()
	defer fake.getStubMutex.RUnlock()
	return len(fake.getStubArgsForCall)
}

func (fake *CustomContex) GetStubCalls(stub func() shim.ChaincodeStubInterface) {
	fake.getStubMutex.Lock()
	defer fake.getStubMutex.Unlock()
	fake.GetStubStub = stub
}

func (fake *CustomContex) GetStubReturns(result1 shim.ChaincodeStubInterface) {
	fake.getStubMutex.Lock()
	defer fake.getStubMutex.Unlock()
	fake.GetStubStub = nil
	fake.getStubReturns = struct {
		result1 shim.ChaincodeStubInterface
	}{result1}
}

func (fake *CustomContex) GetStubReturnsOnCall(i int, result1 shim.ChaincodeStubInterface) {
	fake.getStubMutex.Lock()
	defer fake.getStubMutex.Unlock()
	fake.GetStubStub = nil
	if fake.getStubReturnsOnCall == nil {
		fake.getStubReturnsOnCall = make(map[int]struct {
			result1 shim.ChaincodeStubInterface
		})
	}
	fake.getStubReturnsOnCall[i] = struct {
		result1 shim.ChaincodeStubInterface
	}{result1}
}

func (fake *CustomContex) GetUserId() (string, error) {
	fake.getUserIdMutex.Lock()
	ret, specificReturn := fake.getUserIdReturnsOnCall[len(fake.getUserIdArgsForCall)]
	fake.getUserIdArgsForCall = append(fake.getUserIdArgsForCall, struct {
	}{})
	stub := fake.GetUserIdStub
	fakeReturns := fake.getUserIdReturns
	fake.recordInvocation("GetUserId", []interface{}{})
	fake.getUserIdMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *CustomContex) GetUserIdCallCount() int {
	fake.getUserIdMutex.RLock()
	defer fake.getUserIdMutex.RUnlock()
	return len(fake.getUserIdArgsForCall)
}

func (fake *CustomContex) GetUserIdCalls(stub func() (string, error)) {
	fake.getUserIdMutex.Lock()
	defer fake.getUserIdMutex.Unlock()
	fake.GetUserIdStub = stub
}

func (fake *CustomContex) GetUserIdReturns(result1 string, result2 error) {
	fake.getUserIdMutex.Lock()
	defer fake.getUserIdMutex.Unlock()
	fake.GetUserIdStub = nil
	fake.getUserIdReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *CustomContex) GetUserIdReturnsOnCall(i int, result1 string, result2 error) {
	fake.getUserIdMutex.Lock()
	defer fake.getUserIdMutex.Unlock()
	fake.GetUserIdStub = nil
	if fake.getUserIdReturnsOnCall == nil {
		fake.getUserIdReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getUserIdReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *CustomContex) GetUserType() (string, error) {
	fake.getUserTypeMutex.Lock()
	ret, specificReturn := fake.getUserTypeReturnsOnCall[len(fake.getUserTypeArgsForCall)]
	fake.getUserTypeArgsForCall = append(fake.getUserTypeArgsForCall, struct {
	}{})
	stub := fake.GetUserTypeStub
	fakeReturns := fake.getUserTypeReturns
	fake.recordInvocation("GetUserType", []interface{}{})
	fake.getUserTypeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *CustomContex) GetUserTypeCallCount() int {
	fake.getUserTypeMutex.RLock()
	defer fake.getUserTypeMutex.RUnlock()
	return len(fake.getUserTypeArgsForCall)
}

func (fake *CustomContex) GetUserTypeCalls(stub func() (string, error)) {
	fake.getUserTypeMutex.Lock()
	defer fake.getUserTypeMutex.Unlock()
	fake.GetUserTypeStub = stub
}

func (fake *CustomContex) GetUserTypeReturns(result1 string, result2 error) {
	fake.getUserTypeMutex.Lock()
	defer fake.getUserTypeMutex.Unlock()
	fake.GetUserTypeStub = nil
	fake.getUserTypeReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *CustomContex) GetUserTypeReturnsOnCall(i int, result1 string, result2 error) {
	fake.getUserTypeMutex.Lock()
	defer fake.getUserTypeMutex.Unlock()
	fake.GetUserTypeStub = nil
	if fake.getUserTypeReturnsOnCall == nil {
		fake.getUserTypeReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getUserTypeReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *CustomContex) IteratorResults(arg1 shim.StateQueryIteratorInterface, arg2 interface{}) error {
	fake.iteratorResultsMutex.Lock()
	ret, specificReturn := fake.iteratorResultsReturnsOnCall[len(fake.iteratorResultsArgsForCall)]
	fake.iteratorResultsArgsForCall = append(fake.iteratorResultsArgsForCall, struct {
		arg1 shim.StateQueryIteratorInterface
		arg2 interface{}
	}{arg1, arg2})
	stub := fake.IteratorResultsStub
	fakeReturns := fake.iteratorResultsReturns
	fake.recordInvocation("IteratorResults", []interface{}{arg1, arg2})
	fake.iteratorResultsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *CustomContex) IteratorResultsCallCount() int {
	fake.iteratorResultsMutex.RLock()
	defer fake.iteratorResultsMutex.RUnlock()
	return len(fake.iteratorResultsArgsForCall)
}

func (fake *CustomContex) IteratorResultsCalls(stub func(shim.StateQueryIteratorInterface, interface{}) error) {
	fake.iteratorResultsMutex.Lock()
	defer fake.iteratorResultsMutex.Unlock()
	fake.IteratorResultsStub = stub
}

func (fake *CustomContex) IteratorResultsArgsForCall(i int) (shim.StateQueryIteratorInterface, interface{}) {
	fake.iteratorResultsMutex.RLock()
	defer fake.iteratorResultsMutex.RUnlock()
	argsForCall := fake.iteratorResultsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *CustomContex) IteratorResultsReturns(result1 error) {
	fake.iteratorResultsMutex.Lock()
	defer fake.iteratorResultsMutex.Unlock()
	fake.IteratorResultsStub = nil
	fake.iteratorResultsReturns = struct {
		result1 error
	}{result1}
}

func (fake *CustomContex) IteratorResultsReturnsOnCall(i int, result1 error) {
	fake.iteratorResultsMutex.Lock()
	defer fake.iteratorResultsMutex.Unlock()
	fake.IteratorResultsStub = nil
	if fake.iteratorResultsReturnsOnCall == nil {
		fake.iteratorResultsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.iteratorResultsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *CustomContex) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkProducerMutex.RLock()
	defer fake.checkProducerMutex.RUnlock()
	fake.createOfferMutex.RLock()
	defer fake.createOfferMutex.RUnlock()
	fake.getClientIdentityMutex.RLock()
	defer fake.getClientIdentityMutex.RUnlock()
	fake.getProducerMutex.RLock()
	defer fake.getProducerMutex.RUnlock()
	fake.getResultMutex.RLock()
	defer fake.getResultMutex.RUnlock()
	fake.getSellableMutex.RLock()
	defer fake.getSellableMutex.RUnlock()
	fake.getStubMutex.RLock()
	defer fake.getStubMutex.RUnlock()
	fake.getUserIdMutex.RLock()
	defer fake.getUserIdMutex.RUnlock()
	fake.getUserTypeMutex.RLock()
	defer fake.getUserTypeMutex.RUnlock()
	fake.iteratorResultsMutex.RLock()
	defer fake.iteratorResultsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *CustomContex) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
